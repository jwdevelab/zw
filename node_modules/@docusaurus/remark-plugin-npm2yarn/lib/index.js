"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const tslib_1 = require("tslib");
const unist_util_visit_1 = (0, tslib_1.__importDefault)(require("unist-util-visit"));
const npm_to_yarn_1 = (0, tslib_1.__importDefault)(require("npm-to-yarn"));
// E.g. global install: 'npm i' -> 'yarn'
const convertNpmToYarn = (npmCode) => (0, npm_to_yarn_1.default)(npmCode, 'yarn');
const transformNode = (node, isSync) => {
    const groupIdProp = isSync ? ' groupId="npm2yarn"' : '';
    const npmCode = node.value;
    const yarnCode = convertNpmToYarn(node.value);
    return [
        {
            type: 'jsx',
            value: `<Tabs${groupIdProp}>\n<TabItem value="npm">`,
        },
        {
            type: node.type,
            lang: node.lang,
            value: npmCode,
        },
        {
            type: 'jsx',
            value: '</TabItem>\n<TabItem value="yarn" label="Yarn">',
        },
        {
            type: node.type,
            lang: node.lang,
            value: yarnCode,
        },
        {
            type: 'jsx',
            value: '</TabItem>\n</Tabs>',
        },
    ];
};
const isImport = (node) => node.type === 'import';
const isParent = (node) => Array.isArray(node.children);
const matchNode = (node) => node.type === 'code' && node.meta === 'npm2yarn';
const nodeForImport = {
    type: 'import',
    value: "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';",
};
const plugin = (options = {}) => {
    const { sync = false } = options;
    let transformed = false;
    let alreadyImported = false;
    const transformer = (root) => {
        (0, unist_util_visit_1.default)(root, (node) => {
            if (isImport(node) && node.value.includes('@theme/Tabs')) {
                alreadyImported = true;
            }
            if (isParent(node)) {
                let index = 0;
                while (index < node.children.length) {
                    const child = node.children[index];
                    if (matchNode(child)) {
                        const result = transformNode(child, sync);
                        node.children.splice(index, 1, ...result);
                        index += result.length;
                        transformed = true;
                    }
                    else {
                        index += 1;
                    }
                }
            }
        });
        if (transformed && !alreadyImported) {
            root.children.unshift(nodeForImport);
        }
    };
    return transformer;
};
module.exports = plugin;
//# sourceMappingURL=index.js.map